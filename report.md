レポート
=
(追記)FL実験で実装したオセロAIです。
## 実行方法
### 対戦
```
cargo build --release
./target/release/reversi-rust
```
※ 実行には専用のサーバープログラムが必要です。(追記)
### parse
* (parse済のものを提出した)
* 以下のサイトからlogbook.gamをダウンロードし, src/logbook.gamと配置
  * https://skatgame.net/mburo/log.html
* 以下を実行
```
./target/release/reversi-rust -P
```
* src/databaseが生成される. 

## 工夫
### Rustによる高速化
* ocamlプログラムを参考にRust実装を行った. 
* その結果, 後述の64bit整数を用いたbit boardによる高速化の効果も出たと考えられる. 
* 学科PCでは, 少なくとも読み切りは25手, 中盤は10手読めた. 

### bit boardの実装
* flipや合法手の検索にbit演算を用いた. 
* アルゴリズムおよび実装は以下のサイトを参考にした. 
  * https://zenn.dev/kinakomochi/articles/othello-bitboard

### マルチスレッド
* 一番手前のnodeで, 合法手を4つに分け, 並列に探索した. 
  * 分け方も, move-orderingと合わせて工夫した. (よさそうなものが均等になるように. )
* alpha, beta値は共有した. 
### timeout対策
* 現在の手数と残り時間から, 今回の手の制限時間を決めた.  
* timeout検査用のスレッドを用意し, 制限時間を超えたら, グローバル変数のIS_TIMEOUTをtrueにした. 
* timeout検査を専用のスレッドに分けることで, 通常の探索中のシステムコール呼び出しによるオーバヘッドをなくした. 

### 序盤のdatabase
* 以下のサイトからダウロードできるlogbook.gamをparseした. 
  * https://skatgame.net/mburo/log.html
* parseでは, 最初の20手に関して, bitboardへのエンコード結果と勝敗数を集計して, src/database.rsに保存した. 
* 序盤には, 現在の盤面から1手進めた盤面がdatabaseにあれば, 勝率が50%以上の手から, 勝数に比例した確率で手を選び, 
なければ通常のnega-scout探索を行うようにした. 
  * データベースには回転した盤面が入っていないので, 実行時には8通りに回転した盤面を探索した. 
  *

### 中盤の3段階のdepthでの探索
* 制限時間を過ぎたら, 残りの合法手に対する探索をやめるようにした. 
* 後述するように, 一つ前のdepthにおけるscore順で探索を行うため, 探索が中断しても, 
一つ前のdepthでscoreが上位だった合法手はすでに探索されているので, 
より良い結果を得られる.  

### 中盤のnega-scout + move-ordering
* nega-scoutで実装した. 
  * 参考: https://ja.wikipedia.org/wiki/Negascout
* move-orderingも組み合わせ, 探索順を工夫した. 
* move-orderingの順番の決定は次のように行った. 
  * 最初のdepth以外の初手: 1つ前のdepthでのscore
  * それ以外: 相手の合法手の数の少なさを基準にした. 

### 評価関数
* 10 * openness + weight + 10 * candidates + 50 * stableにした. 
* weightは下記のサイトの「より洗練された重み付けの方法」を採用した. 
  * 他の指標に比べ, 評価が不安定なので, 基本的には他の指標で差がなかった場合に考慮されるように重みを減らした. 
  * https://uguisu.skr.jp/othello/5-1.html
* candidatesは現在の盤面において, 「自分の合法手の数-相手の合法手の数」とした. 
  * 合法手の数が多いほど, 相手の石が自分の石を囲んでおり, 有利なため. 
* stableは確定石の数の差とした. 
  * edgeの4辺と対角線のみカウントした. 
* opennessはその手の解放度とした. 
  * https://www.othello.org/dic/e/51#:~:text=%E6%89%93%E3%81%A3%E3%81%9F%E3%81%93%E3%81%A8%E3%81%A7%E8%A3%8F%E8%BF%94%E3%82%8B,%E3%81%A7%E3%81%82%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%8C%E5%A4%9A%E3%81%84%E3%80%82

### 終盤の読み切り
* 残り25手では完全な読み切りを行った. 
* depthを10にした探索も先に行い, 読みきれない場合に備えた. 
* 読み切りで勝てる手がない場合, depthを10にした探索の結果が最もマシな手を打つようにし, 
相手が読み切っていない場合に勝てる確率を高めた. 
* 終盤dbも検討したが, 残り25手をすべて保存すると, メモリ使用量とデータベース探索時間のほうが
都度探索より負担になることがわかったので, やめた. 

## 対戦結果と考察
* 先輩方のgit projectを2つ見つけたので対戦させた. 
  * https://github.com/gasin/OCallo
  * https://github.com/okuraofvegetable/FL2019-othello
* OCallo : 10試合中, 勝8 : 負1だった. 
* FL2019-othello : 10試合中, 勝6 : 負3だった. 

* 得意不得意は判断できなかったが, 以下の考察をした. 

### 考察1 : 25手読み切れるという長所を活かしきれていないことが, 自分のAIの欠点. 
* 判断理由 : 25手目での勝ち負けと, 最終的な勝ち負けが一致している. 
* 原因 : できるだけマシな手を選ぶのが難しい. (負け確定の場合, 10手先読みの評価でマシなものを採用したが, 相手の先読みを超えられない. )
* 影響 : 序盤および中盤が勝ち負けに影響し, 確率やチューニングのレベル次第になってしまう. 
  * その結果勝率が上がらず, 4試合マッチだと, 勝ち越せない可能性がある.  

### 考察2 : 開放度の考慮が効果的
* 判断理由 : 開放度を導入したら, 勝率が5割~6割から, 6割~8割に上がった. 
* 原因: 
  * 開放度を使わないと, 先輩方の評価関数と似たものとなり, 差をつけられない. 
  * 開放度は中盤の評価において, 直感的にもいいもの. (できるだけ真ん中をひっくり返し, 相手の可能性を狭めるので.)

## 対戦結果(追記)
114勝9敗1分で, 31人中3位でした. 
